{"meta":{"title":"陆刚的博客","subtitle":null,"description":null,"author":"Danile","url":"https://luyuzeee.github.io"},"pages":[{"title":"404","date":"2017-12-05T02:08:05.000Z","updated":"2017-12-05T02:08:05.152Z","comments":true,"path":"404/index.html","permalink":"https://luyuzeee.github.io/404/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-10-22T02:54:39.000Z","updated":"2017-12-05T02:44:01.193Z","comments":false,"path":"categories/index.html","permalink":"https://luyuzeee.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-10-22T02:54:24.000Z","updated":"2017-12-05T02:43:46.271Z","comments":false,"path":"tags/index.html","permalink":"https://luyuzeee.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"vue-cli3学习之-axios封装","slug":"vue-cli3学习之-axios封装","date":"2019-05-13T07:23:25.000Z","updated":"2019-05-13T08:30:35.360Z","comments":true,"path":"2019/05/13/vue-cli3学习之-axios封装/","link":"","permalink":"https://luyuzeee.github.io/2019/05/13/vue-cli3学习之-axios封装/","excerpt":"","text":"vue-cli3学习之-axios封装1，准备地址 baseUrl根据生产与开发环境来改变不同的地址,新建env.js。此处的 ‘/api’ 是在vue.config.js里配置的地址（参考vue-cli3学习之-vue.config.js配置） let baseUrl = ''; if (process.env.NODE_ENV == 'development') { baseUrl = '/api'; } else if (process.env.NODE_ENV == 'production') { //baseUrl = '测试地址'; //baseUrl = '预发布地址'; baseUrl = '生产地址'; } export { baseUrl, } 2，axios请求封装封装的前提，你至少得把axios引入吧！在此不多说了在你的项目中应该有一个plugins文件，里面应该有一个axios.js文件，有的话就打开他，没有的话，那就新建一个吧！ 2-1，这是你需要引入的东西 import { baseUrl, //引入baseUrl } from \"../plugins/env\"; import axios from 'axios'; import qs from 'qs' import { Loading, Message } from 'element-ui' import router from '../router' 2-2，基本的配置与取值，当然，你也可以把值存在store里，你开心就好 axios.defaults.timeout = 10000; //设置请求时间 axios.defaults.baseURL = baseUrl;//设置默认接口地址 axios.defaults.headers = { 'Content-Type': 'application/json; charset=utf-8' }; let loadinginstace = ''; let token = localStorage.getItem('token'); //从localstorage取值 2-3，http请求拦截器 axios.interceptors.request.use( config => { loadinginstace = Loading.service({ lock: true, text: 'Loading', spinner: 'el-icon-loading', background: 'rgba(0, 0, 0, 0.3)', customClass: \"osloading\", fullscreen: true }) if (token) { config.headers['X-Token'] = getToken() } if (config.method === 'post' || config.method === 'put' || config.method === 'delete') { config.data = qs.stringify(config.data) } return config }, error => { loadinginstace.close(); return Promise.reject(error) } ) 2-4，http response 服务器响应拦截器 axios.interceptors.response.use(res => { loadinginstace.close() if (res.data === '' || res.data.length === 0 || res.data === 'undefined' || res.data === undefined) { Message({ type: 'error', message: '数据可能走丢了！' }) } return res.data }, error => { loadinginstace.close() if (error.code === 'ECONNABORTED' && error.message.indexOf('timeout') !== -1) { Message({ type: 'error', message: '请求超时！' }) } const errorInfo = error.response if (errorInfo) { if (errorInfo.status === 401) { router.push({ path: '/login' }) } } return Promise.reject(error) } ); 2-5，get,post请求简单封装 export function fetch(url, params = {}) { return new Promise((resolve, reject) => { axios.get(url, { params: params }) .then(response => { resolve(response.data); }) .catch(err => { reject(err) }) }) } export function post(url, data = {}) { return new Promise((resolve, reject) => { axios.post(url, data) .then(response => { resolve(response.data); }, err => { reject(err) }) }) } 2-5，在main.js中引入，就可以用了 import { post, fetch } from \"./plugins/axios\"; Vue.prototype.$get=fetch; Vue.prototype.$post=post; 使用例子 this.$post(\"/login\",{\"password\": \"admin\",\"username\": \"admin\"}).then((res)=>{ console.log(res) }) 以下是全部代码 import { baseUrl, //引入baseUrl } from \"../plugins/env\"; import axios from 'axios'; import qs from 'qs' import { Loading, Message } from 'element-ui' import router from '../router' axios.defaults.timeout = 10000; //设置请求时间 axios.defaults.baseURL = baseUrl;//设置默认接口地址 axios.defaults.headers = { 'Content-Type': 'application/json; charset=utf-8' }; let loadinginstace = ''; let token = localStorage.getItem('token'); //从localstorage取值 // http请求拦截器 axios.interceptors.request.use( config => { // element ui Loading方法 loadinginstace = Loading.service({ lock: true, text: 'Loading', spinner: 'el-icon-loading', background: 'rgba(0, 0, 0, 0.3)', customClass: \"osloading\", fullscreen: true }) if (token) { config.headers['X-Token'] = getToken() // 让每个请求携带token--['X-Token']为自定义key 请根据实际情况自行修改 } // 判断为post请求，序列化传来的参数 if (config.method === 'post' || config.method === 'put' || config.method === 'delete') { config.data = qs.stringify(config.data) } return config }, error => { loadinginstace.close(); return Promise.reject(error) } ) // http response 服务器响应拦截器， axios.interceptors.response.use(res => { // 请求成功时要做的处理 // 对响应数据做些事，把loading动画关掉 loadinginstace.close() // 对请求成功的值进行统一判断 // 1.判空 if (res.data === '' || res.data.length === 0 || res.data === 'undefined' || res.data === undefined) { Message({ type: 'error', message: '数据可能走丢了！' }) } // 2.错误提示(前提是接口跑通了，只是对里边某些值做下详细判断。要先跟后台商定好，对某个固定的字段进行判断，并且确定固定字段来承接 错误信息，方便展示) // if (res.data && !res.data.success) { // console.log(res.data.error.message) // } return res.data }, error => { loadinginstace.close() // 1.判断请求超时 if (error.code === 'ECONNABORTED' && error.message.indexOf('timeout') !== -1) { Message({ type: 'error', message: '请求超时！' }) // return service.request(originalRequest);//例如再重复请求一次 } // 2.需要重定向到错误页面 const errorInfo = error.response if (errorInfo) { // error =errorInfo.data//页面那边catch的时候就能拿到详细的错误信息,看最下边的Promise.reject if (errorInfo.status === 401) { router.push({ path: '/login' }) } // if (errorInfo.status === 500) { // router.push({ // path: \"/error/500\" // }); // } // if (errorInfo.status === 502) { // router.push({ // path: \"/error/502\" // }); // } // if (errorInfo.status === 404) { // router.push({ // path: \"/error/404\" // }); // } } return Promise.reject(error) } ); /** * 封装get方法 * @param url * @param data * @returns {Promise} */ export function fetch(url, params = {}) { return new Promise((resolve, reject) => { axios.get(url, { params: params }) .then(response => { resolve(response.data); }) .catch(err => { reject(err) }) }) } /** * 封装post请求 * @param url * @param data * @returns {Promise} */ export function post(url, data = {}) { return new Promise((resolve, reject) => { axios.post(url, data) .then(response => { resolve(response.data); }, err => { reject(err) }) }) }","categories":[{"name":"vue-cli3，axios，封装","slug":"vue-cli3，axios，封装","permalink":"https://luyuzeee.github.io/categories/vue-cli3，axios，封装/"}],"tags":[{"name":"vue-cli3，axios，封装","slug":"vue-cli3，axios，封装","permalink":"https://luyuzeee.github.io/tags/vue-cli3，axios，封装/"}]},{"title":"vue-cli3学习之-vue.config.js配置","slug":"vue-cli3学习之-vue.config.js配置","date":"2019-05-12T07:23:25.000Z","updated":"2019-05-13T08:47:04.046Z","comments":true,"path":"2019/05/12/vue-cli3学习之-vue.config.js配置/","link":"","permalink":"https://luyuzeee.github.io/2019/05/12/vue-cli3学习之-vue.config.js配置/","excerpt":"","text":"vue-cli3学习之-vue.config.js配置在你创建的项目根目录中创建vue.config.js文件这个就是你要在axios中配置的代理地址。devServer一块的配置可以参考 https://cli.vuejs.org/zh/config/#css-loaderoptions proxy: { \"/api\": { target: 'http://192.168.43.143:8080', ws: true, pathRewrite: {'^/api' : ''}, changeOrigin: true } } 以下是我新建的一个项目的基本代码，如果有不同需求请自行更改 module.exports = { publicPath: process.env.NODE_ENV === \"production\" ? \"./\" : \"./\", //基本路径 outputDir: \"dist\", //输出文件目录 lintOnSave: true, // eslint-loader 是否在保存的时候检查 assetsDir: 'assets', //放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录。 pages: undefined, //以多页模式构建应用程序。 runtimeCompiler: false, //是否使用包含运行时编译器的 Vue 构建版本 parallel: require('os').cpus().length > 1, //是否为 Babel 或 TypeScript 使用 thread-loader。该选项在系统的 CPU 有多于一个内核时自动启用，仅作用于生产构建，在适当的时候开启几个子进程去并发的执行压缩 transpileDependencies: [], productionSourceMap: false, //生产环境是否生成 sourceMap 文件，一般情况不建议打开 chainWebpack: config => { // 修复HMR config.resolve.symlinks(true); }, configureWebpack: () => {}, devServer: { open: true, //配置自动启动浏览器 disableHostCheck: true, // 禁用webpack热重载检查 解决热更新失效问题 host: \"localhost\", port: 8088, https: false, hotOnly: true, // 热更新 proxy: { //配置自动启动浏览器 \"/api\": { target: 'http://192.168.43.143:8080', ws: true, pathRewrite: {'^/api' : ''}, changeOrigin: true } } // before: app => {} }, css: { modules: false, // 启用 CSS modules //extract: true, // 是否使用css分离插件 sourceMap: false, // 开启 CSS source maps，一般不建议开启 loaderOptions: { // css预设器配置项 sass: { data: ` @import \"@/assets/css/variable.scss\"; @import \"@/assets/css/base.scss\"; @import \"@/assets/css/mixin.scss\"; @import \"@/assets/css/styleElement.scss\"; ` } } }, // parallel: require(\"os\").cpus().length > 1, // 是否为 Babel 或 TypeScript 使用 thread-loader pwa: {}, // 向 PWA 插件传递选项 pluginOptions: {} // 第三方插件配置 }","categories":[{"name":"vue-cli3，vue.config.js，配置","slug":"vue-cli3，vue-config-js，配置","permalink":"https://luyuzeee.github.io/categories/vue-cli3，vue-config-js，配置/"}],"tags":[{"name":"vue-cli3，vue.config.js，配置","slug":"vue-cli3，vue-config-js，配置","permalink":"https://luyuzeee.github.io/tags/vue-cli3，vue-config-js，配置/"}]},{"title":"gulp安装","slug":"gulp搭建","date":"2017-09-12T12:46:25.000Z","updated":"2019-05-13T07:43:31.640Z","comments":true,"path":"2017/09/12/gulp搭建/","link":"","permalink":"https://luyuzeee.github.io/2017/09/12/gulp搭建/","excerpt":"","text":"以下是gulp的安装1，gulp的官网地址gulp官网地址：http://www.gulpjs.com.cn/gulp中文文档：http://www.gulpjs.com.cn/docs/gulp插件地址：http://gulpjs.com/pluginsgulpAPI地址：http://www.gulpjs.com.cn/docs/api/ 2，nodenode下载地址：http://nodejs.cn/download/ 3，npm和cnpmnpm服务器在国外，网络影响大，甚至还会遇到需要翻墙才能下载插件的情况，因此推荐安装cnpm。【淘宝npm镜像，这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步】。镜像地址：http://npm.taobao.org/ 4，全局安装gulp执行cnpm install gulp -g 5，新建package.json执行命令cnpm init (也可以手动在项目根目录上创建) 创建步骤 创建成功后 { “name”: “test”, “version”: “1.0.0”, “description”: “我是描述”, “main”: “index.js”, “scripts”: { “test”: “echo \\”Error: no test specified\\” &amp;&amp; exit 1” }, “author”: “”, “license”: “ISC”} 5，本地安装gulp插件注：全局安装gulp是为了执行gulp任务，本地安装gulp则是为了调用gulp插件的功能进入你的项目文件路径中后，执行cnpm install gulp –save-dev 此步骤完成后：项目文件中多了 node_modules 文件夹，里面是你本地安装的插件 安装gulp插件（已gulp-sass为例）进入你的项目文件路径中后，执行cnpm install gulp-sass –save-dev 常用插件1，sass的编译（gulp-sass）2，less编译 （gulp-less）3，重命名（gulp-rename）4，图片转换为base64-encoded （gulp-img64）5，自动添加css前缀（gulp-autoprefixer）6，压缩css（gulp-clean-css）7，js代码校验（gulp-jshint）8，合并js文件（gulp-concat）9，压缩js代码（gulp-uglify）10，压缩图片（gulp-imagemin）11，自动刷新页面（gulp-livereload，谷歌浏览器亲测，谷歌浏览器需安装livereload插件）12，图片缓存，只有图片替换了才压缩（gulp-cache）13，更改提醒（gulp-notify）14，阻止 gulp 插件发生错误导致进程退出并输出错误日志(gulp-plumber) 6，新建gulpfile.js（重要，重要，重要）gulpfile.js是gulp的配置文件，放于根目录中。1234567891011121314151617//gulpfile.js 示例文件//导入你所需要用的工具包 require(&apos;node_modules里对应模块&apos;)var gulp = require(&apos;gulp&apos;), sass = require(&apos;gulp-sass&apos;);// scss 任务gulp.task(&apos;sass&apos;,function()&#123; return gulp.src(&apos;src/css/test.scss&apos;) //获取该任务需要的文件 .pipe( sass() ) //该任务调用的模块 .pipe( gulp.dest(&apos;src/css&apos;) ); //将在 src/css 文件夹中生产test.css&#125;);// 默认任务gulp.task(&apos;default&apos;,[&apos;sass&apos;,&apos;watch1&apos;]);//监听文件gulp.task(&apos;watch1&apos;,function()&#123; return gulp.watch(&apos;src/css/test.scss&apos;,[&apos;sass&apos;]); //监听 src/css/test.scss 文件，修改时自动执行 sass 任务。&#125;); 详细gulp api介绍，可参考官网：http://www.gulpjs.com.cn/docs/api/ 7，任务文件匹配//使用数组的方式来匹配多种文件123gulp.src([&apos;js/*.js&apos;,&apos;css/*.css&apos;,&apos;*.html&apos;])//以下是匹配一个文件夹下多个htmlgulp.src(&apos;./src/html/**/*.html&apos;) 12gulp.src([*.js,&apos;!b*.js&apos;]) //匹配所有js文件，但排除掉以b开头的js文件gulp.src([&apos;!b*.js&apos;,*.js]) //不会排除任何文件，因为排除模式不能出现在数组的第一个元素中 使用数组的方式还有一个好处就是可以很方便的使用排除模式，在数组中的单个匹配模式前加上!即是排除模式，它会在匹配的结果中排除这个匹配，要注意一点的是不能在数组中的第一个元素中使用排除模式 写在最后HTML ， js , css 压缩（其他插件请参考参见文档 https://gulpjs.com/plugins/）以下是一个简单的HTML ， js , css 压缩gulpfile.js文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*gulpfile.js 示例文件*///导入你所需要用的工具包 require(&apos;node_modules里对应模块&apos;)var gulp = require(&apos;gulp&apos;), sass = require(&apos;gulp-sass&apos;);// 获取 clean-css 模块（用于压缩 css）var cleanCSS = require(&apos;gulp-clean-css&apos;);// 获取 uglify 模块（用于压缩 JS）var uglify = require(&apos;gulp-uglify&apos;);// 获取 rename 模块（用于重命名）var rename = require(&quot;gulp-rename&quot;);// 获取 htmlmin 模块（用于压缩html）var htmlmin = require(&apos;gulp-htmlmin&apos;);// scss 任务gulp.task(&apos;sass&apos;,function()&#123; return gulp.src(&apos;./src/css/**/*.scss&apos;) //获取该任务需要的文件 .pipe( sass() ) //该任务调用的模块 .pipe( gulp.dest(&apos;./src/css&apos;) ); //将在 src/css 文件夹中生产test.css&#125;);// 压缩 css 文件// 在命令行使用 gulp csscompress 启动此任务gulp.task(&apos;csscompress&apos;, function() &#123; // 1. 找到文件 return gulp.src(&apos;./src/css/**/*.css&apos;) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) // 2. 压缩文件 .pipe(cleanCSS()) // 3. 另存压缩后的文件 .pipe(gulp.dest(&apos;./src/dist/css&apos;));&#125;);// 压缩 js 文件// 在命令行使用 gulp jscompress 启动此任务gulp.task(&apos;jscompress&apos;, function() &#123; // 1. 找到文件 return gulp.src(&apos;./src/js/**/*.js&apos;) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) // 2. 压缩文件 .pipe(uglify()) // 3. 另存压缩后的文件 .pipe(gulp.dest(&apos;./src/dist/js&apos;));&#125;);//压缩HTMLgulp.task(&apos;minify&apos;, function() &#123; return gulp.src(&apos;./src/html/**/*.html&apos;) .pipe(htmlmin(&#123; removeComments: true,//清除HTML注释 collapseWhitespace: true,//压缩HTML collapseBooleanAttributes: true,//省略布尔属性的值 &lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt; removeEmptyAttributes: true,//删除所有空格作属性值 &lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt; removeScriptTypeAttributes: true,//删除&lt;script&gt;的type=&quot;text/javascript&quot; removeStyleLinkTypeAttributes: true,//删除&lt;style&gt;和&lt;link&gt;的type=&quot;text/css&quot; minifyJS: true,//压缩页面JS minifyCSS: true//压缩页面CSS &#125;)) .pipe(gulp.dest(&apos;./src/dist/html&apos;));&#125;);// 默认任务gulp.task(&apos;default&apos;,[&apos;auto&apos;]);//监听文件gulp.task(&apos;auto&apos;,function()&#123; gulp.watch(&apos;./src/css/**/*.scss&apos;,[&apos;sass&apos;]); //编译sass gulp.watch(&apos;./src/css/**/*.css&apos;,[&apos;csscompress&apos;]);//压缩css gulp.watch(&apos;./src/js/**/*.js&apos;,[&apos;jscompress&apos;]);//压缩js gulp.watch(&apos;./src/html/**/*.html&apos;,[&apos;minify&apos;]);//压缩html &#125;); 8，运行123gulpgulp xxxxx (xxxxx代表gulpfile.js文件里的任务名称)","categories":[{"name":"gulp，压缩，优化，插件，API","slug":"gulp，压缩，优化，插件，API","permalink":"https://luyuzeee.github.io/categories/gulp，压缩，优化，插件，API/"}],"tags":[{"name":"gulp，压缩，优化，插件，API","slug":"gulp，压缩，优化，插件，API","permalink":"https://luyuzeee.github.io/tags/gulp，压缩，优化，插件，API/"}]},{"title":"placeholder兼容问题","slug":"placeholder兼容问题","date":"2017-07-13T12:46:25.000Z","updated":"2017-12-05T03:12:33.564Z","comments":true,"path":"2017/07/13/placeholder兼容问题/","link":"","permalink":"https://luyuzeee.github.io/2017/07/13/placeholder兼容问题/","excerpt":"","text":"以下是angularJs的兼容，运用指令和IE兼容starterDirective.directive(‘placeholder’, [‘$compile’, function($compile) { return { restrict: ‘A’, scope: {}, link: function(scope, ele, attr) { console.log(ele.position().top); var input = document.createElement(‘input’); var isSupportPlaceholder = ‘placeholder’ in input; if(!isSupportPlaceholder) { var fakePlaceholder = angular.element( ‘‘ + attr[‘placeholder’] + ‘‘); fakePlaceholder.on(‘click’, function(e) { e.stopPropagation(); ele.focus(); }); fakePlaceholder.css({ ‘text-align’: ‘left’, ‘line-height’: ‘34px’ }); scope.getElementPosition = function() { return ele.position(); }; scope.$watch(scope.getElementPosition, function() { fakePlaceholder.css({ ‘top’: ele.position().top + ‘px’, ‘left’: ele.position().left + ‘px’ }); }, true); scope.getElementHeight = function() { return ele.outerHeight(); }; scope.$watch(scope.getElementHeight, function() { fakePlaceholder.css(‘height’, ele.outerHeight() + ‘px’); }); if(ele.css(‘font-size’)) { fakePlaceholder.css(‘font-size’, ele.css(‘font-size’)); } if(ele.css(‘width’)) { fakePlaceholder.css(‘width’, ele.css(‘width’)); } if(ele.css(‘text-indent’)) { fakePlaceholder.css(‘text-indent’, parseInt(ele.css(‘text-indent’)) + parseInt(ele.css(‘border-left-width’)) ); } if(ele.css(‘padding-left’)) { fakePlaceholder.css(‘padding-left’, ele.css(‘padding-left’)); } if(ele.css(‘margin-top’)) { fakePlaceholder.css(‘margin-top’, ele.css(‘margin-top’)); } ele.before(fakePlaceholder); $compile(fakePlaceholder)(scope); ele.on(‘focus’, function() { fakePlaceholder.hide(); }).on(‘blur’, function() { if(ele.val() === ‘’) { fakePlaceholder.show(); } }); scope.isElementVisible = function() { return ele.is(‘:visible’); }; scope.$watch(scope.isElementVisible, function() { var displayVal = ele.is(‘:visible’) ? ‘block’ : ‘none’; fakePlaceholder.css(‘display’, displayVal); if(displayVal === ‘blcok’ &amp;&amp; ele.val()) { fakePlaceholder.hide(); } }); scope.hasValue = function() { return ele.val(); }; scope.$watch(scope.hasValue, function() { if(ele.val()) { fakePlaceholder.hide(); } }); } } };}]); &lt;!–[if lte IE 9]&gt; &lt;script&gt; $(function(){ /placeholder兼容/ $(‘[placeholder]’).each(function(){ var defaultvalue=$(this).attr(“placeholder”); var altercss=$(this).attr(“altercss”); if($.trim($(this).val())===’’){ $(this).val(defaultvalue); if(altercss){$(this).addClass(altercss);} } $(this).focus(function(){ if($(this).val()==defaultvalue){ $(this).val(‘’); if(altercss){$(this).removeClass(altercss);} } }).blur(function(){ if($.trim($(this).val())===’’){ $(this).val(defaultvalue); if(altercss){$(this).addClass(altercss);} } }); }); }); &lt;/script&gt; &lt;![endif]–&gt; 以上有自己工作总结，欢迎广大群众提意见。真诚向您学习！！！！！！","categories":[{"name":"兼容，placeholder","slug":"兼容，placeholder","permalink":"https://luyuzeee.github.io/categories/兼容，placeholder/"}],"tags":[{"name":"兼容，placeholder，angularJs，IE","slug":"兼容，placeholder，angularJs，IE","permalink":"https://luyuzeee.github.io/tags/兼容，placeholder，angularJs，IE/"}]}]}
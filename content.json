{"meta":{"title":"陆刚的博客","subtitle":null,"description":null,"author":"Danile","url":"https://luyuzeee.github.io"},"pages":[{"title":"404","date":"2017-12-05T02:08:05.000Z","updated":"2017-12-05T02:08:05.152Z","comments":true,"path":"404/index.html","permalink":"https://luyuzeee.github.io/404/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-10-22T02:54:39.000Z","updated":"2017-12-05T02:44:01.193Z","comments":false,"path":"categories/index.html","permalink":"https://luyuzeee.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-10-22T02:54:24.000Z","updated":"2017-12-05T02:43:46.271Z","comments":false,"path":"tags/index.html","permalink":"https://luyuzeee.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"记一次H5活动的微信授权与分享的坑","slug":"记一次H5活动的微信授权与分享的坑","date":"2019-12-24T08:30:45.000Z","updated":"2019-12-24T13:31:03.301Z","comments":true,"path":"2019/12/24/记一次H5活动的微信授权与分享的坑/","link":"","permalink":"https://luyuzeee.github.io/2019/12/24/记一次H5活动的微信授权与分享的坑/","excerpt":"","text":"H5活动的微信授权与分享背景某一天接到个H5的活动页面需求，需求是如下： 总共三个页面（不重要） 第一个页面点击跳转第二个页面获取授权，拿取微信信息 在第二个页面能长按保存整个图片 自定义分享内容，（三个页面都能分享，是同样的分享内容）开始1，你需要准备的东西 微信公众平台——服务号 jquery html2canvas.js jweixin-1.4.0.js sha1.js2，准备页面3，公众平台配置网页授权域名在微信公众号请求用户网页授权之前，开发者需要先到公众平台官网中的“开发 - 接口权限 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息”的配置选项中，修改授权回调域名。请注意，这里填写的是域名（是一个字符串），而不是URL，因此请勿加 http:// 等协议头；前端的东西必须通过这个域名能访问到。 参数定义 4，微信授权微信授权分为两种形式，snsapi_base，snsapi_userinfo，区别在于前者是静默状态，只能获取进入页面的用户的openid的，后者是会出现以下页面的，获取用户的基本信息，需要用户手动同意授权，如下：要到达上面的页面，需要开发者调用https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&redirect_uri=REDIRECT_URI&response_type=code&scope=SCOPE&state=STATE#wechat_redirect //若提示“该链接无法访问”，请检查参数是否填写错误，是否拥有scope参数对应的授权作用域权限。 上面链接的意思就是，跳转到授权页面，获取code(注意不要改变参数顺序)每个参数的定义如下： 参数定义 以上其实主要修改的参数就是appid和redirect_uri，一个是你的公众号的唯一id,一个是你授权成功后的重定向路径（授权成功后要跳转的页面）。 ## 5，通过code获取access_token与openId，并且获取到信息 获取token的接口 https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&secret=SECRET&code=CODE&grant_type=authorization_code 这儿你可能需要这个函数，获取url参数12345function getUrlParam(name) &#123; var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;); var r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null;&#125; 这儿H5前端请求会存在跨域问题，微信也不支持jsonp,这儿需要解决跨域的问题，才能请求到数据，我在这儿是把code参数传给后端让后端去拿数据，并且通过access_token与openId去拿取用户信息，后面的跨域接口，都是通过后端去转发的请根据你的业务需求，与后端配合解决 获取信息得接口： https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&openid=OPENID&lang=zh_CN 以上就拿到信息了：1234567891011&#123; &quot;openid&quot;:&quot; OPENID&quot;, &quot;nickname&quot;: NICKNAME, &quot;sex&quot;:&quot;1&quot;, &quot;province&quot;:&quot;PROVINCE&quot;, &quot;city&quot;:&quot;CITY&quot;, &quot;country&quot;:&quot;COUNTRY&quot;, &quot;headimgurl&quot;:&quot;http://thirdwx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/46&quot;, &quot;privilege&quot;:[ &quot;PRIVILEGE1&quot; &quot;PRIVILEGE2&quot; ], &quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;&#125; 了解更多请参考微信网页授权文档 6，接下来是微信分享自定义 微信分享 我们一般是想想要下面的这种结果，微信官方的文档就很清晰了微信JS_SDK 1，绑定域名同授权的域名方式，进入“公众号设置”的“功能设置”里填写“JS接口安全域名”。 2，引入js1.0.0的版本存在二次分享无效的问题，1.2.0以上就没出现过了1http://res.wx.qq.com/open/js/jweixin-1.4.0.js 3，基础access_token获取这儿的token和网页授权的token是不一样的,通过下面的接口获取1https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Get_access_token.html 4，获得jsapi_ticket拿到access_token后，请求下面的接口，获得ticket，获得jsapi_ticket之后，就可以生成JS-SDK权限验证的签名了。1https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&amp;type=jsapi 5，JS-SDK权限验证签名官网说明要以下四个参数1234noncestr=&apos;&apos; //随机字符串jsapi_ticket=&apos;&apos; //获取的jsapi_tickettimestamp=&apos;&apos; //当前时间戳（以秒换算）url=&apos;&apos; //需要调用的当前url（只需要‘#’前面的部分） 1，随机字符串1Math.random().toString(36).slice(-8) 2，获取的jsapi_ticket3，时间戳1Date.parse(new Date()) / 1000 4，当前网页的URL1window.location.href.split(&apos;#&apos;)[0] 5，签名参数按照字段名的ASCII 码从小到大排序1234567891011121314function sort_ASCII(obj) &#123; var arr = new Array(); var num = 0; for (var i in obj) &#123; arr[num] = i; num++; &#125; var sortArr = arr.sort(); var sortObj = &#123;&#125;; for (var i in sortArr) &#123; sortObj[sortArr[i]] = obj[sortArr[i]]; &#125; return sortObj;&#125; 6，排序后拼接成如下字符串1jsapi_ticket=对应的值&amp;noncestr=对应的值&amp;timestamp=对应的值&amp;url=对应的值 7，调用sha1.js，进行签名，后获得签名字符串这个就要用到文章开始得工具了sha1.js12var str = &apos;jsapi_ticket=对应的值&amp;noncestr=对应的值&amp;timestamp=对应的值&amp;url=对应的值&apos;;sha1(str); 6，注入wx.config配置参数timestamp,nonceStr,signature,即上一步所生成的字符串，但是得与上面得保持一致，appId就是前面授权时得唯一标识Id12345678wx.config(&#123; debug: true, // 调试（调试完毕后请关闭或者注释） appId: &apos;&apos;, // 必填，公众号的唯一标识 timestamp: &apos;&apos;, // 必填，生成签名的时间戳 nonceStr: &apos;&apos;, // 必填，生成签名的随机串 signature: &apos;&apos;,// 必填，签名 jsApiList: [&apos;onMenuShareAppMessage&apos;, &apos;onMenuShareTimeline&apos;] // 必填，需要调用的接口列表&#125;); 7, 通过ready接口处理成功验证(在此调用接口)，error接口处理错误1234567891011121314//需在用户可能点击分享按钮前就先调用wx.ready(function () &#123; wx.onMenuShareAppMessage(&#123; title: &apos;&apos;, // 分享标题 desc: &apos;&apos;, // 分享描述 link: &apos;&apos;, // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致 imgUrl: &apos;&apos;, // 分享图标 success: function () &#123;&#125;, cancel: function () &#123;&#125; &#125;);&#125;);wx.error(function () &#123; console.log(&quot;错误&quot;)&#125;); 更多接口，请参考微信文档 7，长按保存图片（html2canvas）用这个原因时因为，H5不可能是一张图，它是多张图与标签组合的，往往需要微信用户的名字与头像和活动的结果图一起构成的，但是如果直接调用微信的保存图片，只是保存了选中的图片，所以，我们需要把网页截屏成图片覆盖html，让用户直接保存这张截图。网上很多介绍都很简单，类似与123html2canvas(document.querySelector(&quot;#capture&quot;)).then(canvas =&gt; &#123; var imgUri = canvas.toDataURL(&quot;image/png&quot;, 1);&#125;); 我大概讲一下我所遇到的坑吧！解决图片跨域,画布污染的问题，crossorigin=”anonymous” 和 useCORS: true调用插件，截屏，你需要选择body一下的某个容器。123456789101112html2canvas( document.getElementById(&quot;content&quot;), &#123; useCORS: true, allowTaint: true &#125;).then(function (canvas) &#123; // 获取生成的图片的base64 var imgUri = canvas.toDataURL(&quot;image/png&quot;, 1); //压缩 suofang(imgUri, &apos;1.5&apos;); &#125;); base64压缩，不多讲了，网上一大堆，直接上函数吧1234567891011121314151617181920function suofang(base64, bili) &#123; var _img = new Image(); _img.src = base64; _img.onload = function () &#123; var _canvas = document.createElement(&quot;canvas&quot;); var w = this.width / bili; var h = this.height / bili; _canvas.setAttribute(&quot;width&quot;, w); _canvas.setAttribute(&quot;height&quot;, h); _canvas.getContext(&quot;2d&quot;).drawImage(this, 0, 0, w, h); var base64 = _canvas.toDataURL(&quot;image/jpeg&quot;); _canvas.toBlob(function (blob) &#123; if (blob.size &gt; 1024 * 1024) &#123; suofang(base64, bili); &#125; else &#123; $(&quot;#newImg&quot;).attr(&quot;src&quot;, base64); &#125; &#125;, &quot;image/jpeg&quot;); &#125;&#125; 了解更多canvas画布污染和图片跨域的问题，请参考安全性和“被污染”的 canvas 到此，就是本次H5活动页的经过。接受所有向上的建议，向各位大佬学习，不接受无理的吐槽喷人。","categories":[{"name":"微信授权，分享，html2canvas保存图片","slug":"微信授权，分享，html2canvas保存图片","permalink":"https://luyuzeee.github.io/categories/微信授权，分享，html2canvas保存图片/"}],"tags":[{"name":"H5，微信授权，分享，html2canvas保存图片","slug":"H5，微信授权，分享，html2canvas保存图片","permalink":"https://luyuzeee.github.io/tags/H5，微信授权，分享，html2canvas保存图片/"}]},{"title":"分享一个H5移动端适配方案","slug":"分享一个H5移动端适配方案","date":"2019-08-13T03:24:16.000Z","updated":"2019-12-24T13:23:24.504Z","comments":true,"path":"2019/08/13/分享一个H5移动端适配方案/","link":"","permalink":"https://luyuzeee.github.io/2019/08/13/分享一个H5移动端适配方案/","excerpt":"","text":"分享一个H5移动端适配方案什么是viewport什么是viewport-fit?1&lt;meta name=&quot;viewport&quot; id=&quot;view&quot; content=&quot;width=750, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, viewport-fit=cover&quot;&gt; 1234&lt;script&gt; var viewWidth = window.innerWidth / 750; document.getElementById(&quot;view&quot;).setAttribute(&apos;content&apos;, &apos;width=750, initial-scale=&apos; + viewWidth + &apos;, maximum-scale=&apos; + viewWidth + &apos;, minimum-scale=&apos; + viewWidth + &apos;, user-scalable=no, viewport-fit=cover&apos;);&lt;/script&gt; 常规的适配就是媒体查询，rem、em，相信大家都清楚了，上面的方法，我是看了斗鱼的网站，我才知道，原来还有这种适配。大家可以随便写个斜面试一试 上面的方案就可以直接去用px了，就不需要rem的换算了，麻烦，比如一张背景图是750 X 1500的，那么这个元素的宽高，就直接写成width:7500px;height:1500px;,其他的交给viewport吧。 后期优化，监听视窗宽度，动态设置缩放比例，利用viewport-fit填充页面，这儿需要注意的是，不是每个屏幕都是矩形的，比如iphone刘海屏，所以填充时要注意这一点。 还有就是可以搭配vh,vw使用","categories":[{"name":"移动端适配，viewport-fit=cover，viewport","slug":"移动端适配，viewport-fit-cover，viewport","permalink":"https://luyuzeee.github.io/categories/移动端适配，viewport-fit-cover，viewport/"}],"tags":[{"name":"H5，移动端适配，viewport-fit=cover，viewport","slug":"H5，移动端适配，viewport-fit-cover，viewport","permalink":"https://luyuzeee.github.io/tags/H5，移动端适配，viewport-fit-cover，viewport/"}]},{"title":"vue-cli3学习之-axios封装","slug":"vue-cli3学习之-axios封装","date":"2018-05-13T07:23:25.000Z","updated":"2019-12-24T13:23:26.519Z","comments":true,"path":"2018/05/13/vue-cli3学习之-axios封装/","link":"","permalink":"https://luyuzeee.github.io/2018/05/13/vue-cli3学习之-axios封装/","excerpt":"","text":"vue-cli3学习之-axios封装1，准备地址 baseUrl根据生产与开发环境来改变不同的地址,新建env.js。此处的 ‘/api’ 是在vue.config.js里配置的地址（参考vue-cli3学习之-vue.config.js配置） let baseUrl = ''; if (process.env.NODE_ENV == 'development') { baseUrl = '/api'; } else if (process.env.NODE_ENV == 'production') { //baseUrl = '测试地址'; //baseUrl = '预发布地址'; baseUrl = '生产地址'; } export { baseUrl, } 2，axios请求封装封装的前提，你至少得把axios引入吧！在此不多说了在你的项目中应该有一个plugins文件，里面应该有一个axios.js文件，有的话就打开他，没有的话，那就新建一个吧！ 2-1，这是你需要引入的东西 import { baseUrl, //引入baseUrl } from \"../plugins/env\"; import axios from 'axios'; import qs from 'qs' import { Loading, Message } from 'element-ui' import router from '../router' 2-2，基本的配置与取值，当然，你也可以把值存在store里，你开心就好 axios.defaults.timeout = 10000; //设置请求时间 axios.defaults.baseURL = baseUrl;//设置默认接口地址 axios.defaults.headers = { 'Content-Type': 'application/json; charset=utf-8' }; let loadinginstace = ''; let token = localStorage.getItem('token'); //从localstorage取值 2-3，http请求拦截器 axios.interceptors.request.use( config => { loadinginstace = Loading.service({ lock: true, text: 'Loading', spinner: 'el-icon-loading', background: 'rgba(0, 0, 0, 0.3)', customClass: \"osloading\", fullscreen: true }) if (token) { config.headers['X-Token'] = getToken() } if (config.method === 'post' || config.method === 'put' || config.method === 'delete') { config.data = qs.stringify(config.data) } return config }, error => { loadinginstace.close(); return Promise.reject(error) } ) 2-4，http response 服务器响应拦截器 axios.interceptors.response.use(res => { loadinginstace.close() if (res.data === '' || res.data.length === 0 || res.data === 'undefined' || res.data === undefined) { Message({ type: 'error', message: '数据可能走丢了！' }) } return res.data }, error => { loadinginstace.close() if (error.code === 'ECONNABORTED' && error.message.indexOf('timeout') !== -1) { Message({ type: 'error', message: '请求超时！' }) } const errorInfo = error.response if (errorInfo) { if (errorInfo.status === 401) { router.push({ path: '/login' }) } } return Promise.reject(error) } ); 2-5，get,post请求简单封装 export function fetch(url, params = {}) { return new Promise((resolve, reject) => { axios.get(url, { params: params }) .then(response => { resolve(response.data); }) .catch(err => { reject(err) }) }) } export function post(url, data = {}) { return new Promise((resolve, reject) => { axios.post(url, data) .then(response => { resolve(response.data); }, err => { reject(err) }) }) } 2-5，在main.js中引入，就可以用了 import { post, fetch } from \"./plugins/axios\"; Vue.prototype.$get=fetch; Vue.prototype.$post=post; 使用例子 this.$post(\"/login\",{\"password\": \"admin\",\"username\": \"admin\"}).then((res)=>{ console.log(res) }) 以下是全部代码 import { baseUrl, //引入baseUrl } from \"../plugins/env\"; import axios from 'axios'; import qs from 'qs' import { Loading, Message } from 'element-ui' import router from '../router' axios.defaults.timeout = 10000; //设置请求时间 axios.defaults.baseURL = baseUrl;//设置默认接口地址 axios.defaults.headers = { 'Content-Type': 'application/json; charset=utf-8' }; let loadinginstace = ''; let token = localStorage.getItem('token'); //从localstorage取值 // http请求拦截器 axios.interceptors.request.use( config => { // element ui Loading方法 loadinginstace = Loading.service({ lock: true, text: 'Loading', spinner: 'el-icon-loading', background: 'rgba(0, 0, 0, 0.3)', customClass: \"osloading\", fullscreen: true }) if (token) { config.headers['X-Token'] = getToken() // 让每个请求携带token--['X-Token']为自定义key 请根据实际情况自行修改 } // 判断为post请求，序列化传来的参数 if (config.method === 'post' || config.method === 'put' || config.method === 'delete') { config.data = qs.stringify(config.data) } return config }, error => { loadinginstace.close(); return Promise.reject(error) } ) // http response 服务器响应拦截器， axios.interceptors.response.use(res => { // 请求成功时要做的处理 // 对响应数据做些事，把loading动画关掉 loadinginstace.close() // 对请求成功的值进行统一判断 // 1.判空 if (res.data === '' || res.data.length === 0 || res.data === 'undefined' || res.data === undefined) { Message({ type: 'error', message: '数据可能走丢了！' }) } // 2.错误提示(前提是接口跑通了，只是对里边某些值做下详细判断。要先跟后台商定好，对某个固定的字段进行判断，并且确定固定字段来承接 错误信息，方便展示) // if (res.data && !res.data.success) { // console.log(res.data.error.message) // } return res.data }, error => { loadinginstace.close() // 1.判断请求超时 if (error.code === 'ECONNABORTED' && error.message.indexOf('timeout') !== -1) { Message({ type: 'error', message: '请求超时！' }) // return service.request(originalRequest);//例如再重复请求一次 } // 2.需要重定向到错误页面 const errorInfo = error.response if (errorInfo) { // error =errorInfo.data//页面那边catch的时候就能拿到详细的错误信息,看最下边的Promise.reject if (errorInfo.status === 401) { router.push({ path: '/login' }) } // if (errorInfo.status === 500) { // router.push({ // path: \"/error/500\" // }); // } // if (errorInfo.status === 502) { // router.push({ // path: \"/error/502\" // }); // } // if (errorInfo.status === 404) { // router.push({ // path: \"/error/404\" // }); // } } return Promise.reject(error) } ); /** * 封装get方法 * @param url * @param data * @returns {Promise} */ export function fetch(url, params = {}) { return new Promise((resolve, reject) => { axios.get(url, { params: params }) .then(response => { resolve(response.data); }) .catch(err => { reject(err) }) }) } /** * 封装post请求 * @param url * @param data * @returns {Promise} */ export function post(url, data = {}) { return new Promise((resolve, reject) => { axios.post(url, data) .then(response => { resolve(response.data); }, err => { reject(err) }) }) }","categories":[{"name":"vue-cli3，axios，封装","slug":"vue-cli3，axios，封装","permalink":"https://luyuzeee.github.io/categories/vue-cli3，axios，封装/"}],"tags":[{"name":"vue-cli3，axios，封装","slug":"vue-cli3，axios，封装","permalink":"https://luyuzeee.github.io/tags/vue-cli3，axios，封装/"}]},{"title":"vue-cli3学习之-vue.config.js配置","slug":"vue-cli3学习之-vue.config.js配置","date":"2018-05-12T07:23:25.000Z","updated":"2019-12-24T13:13:29.937Z","comments":true,"path":"2018/05/12/vue-cli3学习之-vue.config.js配置/","link":"","permalink":"https://luyuzeee.github.io/2018/05/12/vue-cli3学习之-vue.config.js配置/","excerpt":"","text":"vue-cli3学习之-vue.config.js配置在你创建的项目根目录中创建vue.config.js文件这个就是你要在axios中配置的代理地址。devServer一块的配置可以参考 https://cli.vuejs.org/zh/config/#css-loaderoptions proxy: { \"/api\": { target: 'http://192.168.43.143:8080', ws: true, pathRewrite: {'^/api' : ''}, changeOrigin: true } } 以下是我新建的一个项目的基本代码，如果有不同需求请自行更改 module.exports = { publicPath: process.env.NODE_ENV === \"production\" ? \"./\" : \"./\", //基本路径 outputDir: \"dist\", //输出文件目录 lintOnSave: true, // eslint-loader 是否在保存的时候检查 assetsDir: 'assets', //放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录。 pages: undefined, //以多页模式构建应用程序。 runtimeCompiler: false, //是否使用包含运行时编译器的 Vue 构建版本 parallel: require('os').cpus().length > 1, //是否为 Babel 或 TypeScript 使用 thread-loader。该选项在系统的 CPU 有多于一个内核时自动启用，仅作用于生产构建，在适当的时候开启几个子进程去并发的执行压缩 transpileDependencies: [], productionSourceMap: false, //生产环境是否生成 sourceMap 文件，一般情况不建议打开 chainWebpack: config => { // 修复HMR config.resolve.symlinks(true); }, configureWebpack: () => {}, devServer: { open: true, //配置自动启动浏览器 disableHostCheck: true, // 禁用webpack热重载检查 解决热更新失效问题 host: \"localhost\", port: 8088, https: false, hotOnly: true, // 热更新 proxy: { //配置自动启动浏览器 \"/api\": { target: 'http://192.168.43.143:8080', ws: true, pathRewrite: {'^/api' : ''}, changeOrigin: true } } // before: app => {} }, css: { modules: false, // 启用 CSS modules //extract: true, // 是否使用css分离插件 sourceMap: false, // 开启 CSS source maps，一般不建议开启 loaderOptions: { // css预设器配置项 sass: { data: ` @import \"@/assets/css/variable.scss\"; @import \"@/assets/css/base.scss\"; @import \"@/assets/css/mixin.scss\"; @import \"@/assets/css/styleElement.scss\"; ` } } }, // parallel: require(\"os\").cpus().length > 1, // 是否为 Babel 或 TypeScript 使用 thread-loader pwa: {}, // 向 PWA 插件传递选项 pluginOptions: {} // 第三方插件配置 }","categories":[{"name":"vue-cli3，vue.config.js，配置","slug":"vue-cli3，vue-config-js，配置","permalink":"https://luyuzeee.github.io/categories/vue-cli3，vue-config-js，配置/"}],"tags":[{"name":"vue-cli3，vue.config.js，配置","slug":"vue-cli3，vue-config-js，配置","permalink":"https://luyuzeee.github.io/tags/vue-cli3，vue-config-js，配置/"}]},{"title":"gulp安装","slug":"gulp搭建","date":"2017-09-12T12:46:25.000Z","updated":"2019-05-13T07:43:31.640Z","comments":true,"path":"2017/09/12/gulp搭建/","link":"","permalink":"https://luyuzeee.github.io/2017/09/12/gulp搭建/","excerpt":"","text":"以下是gulp的安装1，gulp的官网地址gulp官网地址：http://www.gulpjs.com.cn/gulp中文文档：http://www.gulpjs.com.cn/docs/gulp插件地址：http://gulpjs.com/pluginsgulpAPI地址：http://www.gulpjs.com.cn/docs/api/ 2，nodenode下载地址：http://nodejs.cn/download/ 3，npm和cnpmnpm服务器在国外，网络影响大，甚至还会遇到需要翻墙才能下载插件的情况，因此推荐安装cnpm。【淘宝npm镜像，这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步】。镜像地址：http://npm.taobao.org/ 4，全局安装gulp执行cnpm install gulp -g 5，新建package.json执行命令cnpm init (也可以手动在项目根目录上创建) 创建步骤 创建成功后 { “name”: “test”, “version”: “1.0.0”, “description”: “我是描述”, “main”: “index.js”, “scripts”: { “test”: “echo \\”Error: no test specified\\” &amp;&amp; exit 1” }, “author”: “”, “license”: “ISC”} 5，本地安装gulp插件注：全局安装gulp是为了执行gulp任务，本地安装gulp则是为了调用gulp插件的功能进入你的项目文件路径中后，执行cnpm install gulp –save-dev 此步骤完成后：项目文件中多了 node_modules 文件夹，里面是你本地安装的插件 安装gulp插件（已gulp-sass为例）进入你的项目文件路径中后，执行cnpm install gulp-sass –save-dev 常用插件1，sass的编译（gulp-sass）2，less编译 （gulp-less）3，重命名（gulp-rename）4，图片转换为base64-encoded （gulp-img64）5，自动添加css前缀（gulp-autoprefixer）6，压缩css（gulp-clean-css）7，js代码校验（gulp-jshint）8，合并js文件（gulp-concat）9，压缩js代码（gulp-uglify）10，压缩图片（gulp-imagemin）11，自动刷新页面（gulp-livereload，谷歌浏览器亲测，谷歌浏览器需安装livereload插件）12，图片缓存，只有图片替换了才压缩（gulp-cache）13，更改提醒（gulp-notify）14，阻止 gulp 插件发生错误导致进程退出并输出错误日志(gulp-plumber) 6，新建gulpfile.js（重要，重要，重要）gulpfile.js是gulp的配置文件，放于根目录中。1234567891011121314151617//gulpfile.js 示例文件//导入你所需要用的工具包 require(&apos;node_modules里对应模块&apos;)var gulp = require(&apos;gulp&apos;), sass = require(&apos;gulp-sass&apos;);// scss 任务gulp.task(&apos;sass&apos;,function()&#123; return gulp.src(&apos;src/css/test.scss&apos;) //获取该任务需要的文件 .pipe( sass() ) //该任务调用的模块 .pipe( gulp.dest(&apos;src/css&apos;) ); //将在 src/css 文件夹中生产test.css&#125;);// 默认任务gulp.task(&apos;default&apos;,[&apos;sass&apos;,&apos;watch1&apos;]);//监听文件gulp.task(&apos;watch1&apos;,function()&#123; return gulp.watch(&apos;src/css/test.scss&apos;,[&apos;sass&apos;]); //监听 src/css/test.scss 文件，修改时自动执行 sass 任务。&#125;); 详细gulp api介绍，可参考官网：http://www.gulpjs.com.cn/docs/api/ 7，任务文件匹配//使用数组的方式来匹配多种文件123gulp.src([&apos;js/*.js&apos;,&apos;css/*.css&apos;,&apos;*.html&apos;])//以下是匹配一个文件夹下多个htmlgulp.src(&apos;./src/html/**/*.html&apos;) 12gulp.src([*.js,&apos;!b*.js&apos;]) //匹配所有js文件，但排除掉以b开头的js文件gulp.src([&apos;!b*.js&apos;,*.js]) //不会排除任何文件，因为排除模式不能出现在数组的第一个元素中 使用数组的方式还有一个好处就是可以很方便的使用排除模式，在数组中的单个匹配模式前加上!即是排除模式，它会在匹配的结果中排除这个匹配，要注意一点的是不能在数组中的第一个元素中使用排除模式 写在最后HTML ， js , css 压缩（其他插件请参考参见文档 https://gulpjs.com/plugins/）以下是一个简单的HTML ， js , css 压缩gulpfile.js文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*gulpfile.js 示例文件*///导入你所需要用的工具包 require(&apos;node_modules里对应模块&apos;)var gulp = require(&apos;gulp&apos;), sass = require(&apos;gulp-sass&apos;);// 获取 clean-css 模块（用于压缩 css）var cleanCSS = require(&apos;gulp-clean-css&apos;);// 获取 uglify 模块（用于压缩 JS）var uglify = require(&apos;gulp-uglify&apos;);// 获取 rename 模块（用于重命名）var rename = require(&quot;gulp-rename&quot;);// 获取 htmlmin 模块（用于压缩html）var htmlmin = require(&apos;gulp-htmlmin&apos;);// scss 任务gulp.task(&apos;sass&apos;,function()&#123; return gulp.src(&apos;./src/css/**/*.scss&apos;) //获取该任务需要的文件 .pipe( sass() ) //该任务调用的模块 .pipe( gulp.dest(&apos;./src/css&apos;) ); //将在 src/css 文件夹中生产test.css&#125;);// 压缩 css 文件// 在命令行使用 gulp csscompress 启动此任务gulp.task(&apos;csscompress&apos;, function() &#123; // 1. 找到文件 return gulp.src(&apos;./src/css/**/*.css&apos;) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) // 2. 压缩文件 .pipe(cleanCSS()) // 3. 另存压缩后的文件 .pipe(gulp.dest(&apos;./src/dist/css&apos;));&#125;);// 压缩 js 文件// 在命令行使用 gulp jscompress 启动此任务gulp.task(&apos;jscompress&apos;, function() &#123; // 1. 找到文件 return gulp.src(&apos;./src/js/**/*.js&apos;) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) // 2. 压缩文件 .pipe(uglify()) // 3. 另存压缩后的文件 .pipe(gulp.dest(&apos;./src/dist/js&apos;));&#125;);//压缩HTMLgulp.task(&apos;minify&apos;, function() &#123; return gulp.src(&apos;./src/html/**/*.html&apos;) .pipe(htmlmin(&#123; removeComments: true,//清除HTML注释 collapseWhitespace: true,//压缩HTML collapseBooleanAttributes: true,//省略布尔属性的值 &lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt; removeEmptyAttributes: true,//删除所有空格作属性值 &lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt; removeScriptTypeAttributes: true,//删除&lt;script&gt;的type=&quot;text/javascript&quot; removeStyleLinkTypeAttributes: true,//删除&lt;style&gt;和&lt;link&gt;的type=&quot;text/css&quot; minifyJS: true,//压缩页面JS minifyCSS: true//压缩页面CSS &#125;)) .pipe(gulp.dest(&apos;./src/dist/html&apos;));&#125;);// 默认任务gulp.task(&apos;default&apos;,[&apos;auto&apos;]);//监听文件gulp.task(&apos;auto&apos;,function()&#123; gulp.watch(&apos;./src/css/**/*.scss&apos;,[&apos;sass&apos;]); //编译sass gulp.watch(&apos;./src/css/**/*.css&apos;,[&apos;csscompress&apos;]);//压缩css gulp.watch(&apos;./src/js/**/*.js&apos;,[&apos;jscompress&apos;]);//压缩js gulp.watch(&apos;./src/html/**/*.html&apos;,[&apos;minify&apos;]);//压缩html &#125;); 8，运行123gulpgulp xxxxx (xxxxx代表gulpfile.js文件里的任务名称)","categories":[{"name":"gulp，压缩，优化，插件，API","slug":"gulp，压缩，优化，插件，API","permalink":"https://luyuzeee.github.io/categories/gulp，压缩，优化，插件，API/"}],"tags":[{"name":"gulp，压缩，优化，插件，API","slug":"gulp，压缩，优化，插件，API","permalink":"https://luyuzeee.github.io/tags/gulp，压缩，优化，插件，API/"}]},{"title":"placeholder兼容问题","slug":"placeholder兼容问题","date":"2017-07-13T12:46:25.000Z","updated":"2017-12-05T03:12:33.564Z","comments":true,"path":"2017/07/13/placeholder兼容问题/","link":"","permalink":"https://luyuzeee.github.io/2017/07/13/placeholder兼容问题/","excerpt":"","text":"以下是angularJs的兼容，运用指令和IE兼容starterDirective.directive(‘placeholder’, [‘$compile’, function($compile) { return { restrict: ‘A’, scope: {}, link: function(scope, ele, attr) { console.log(ele.position().top); var input = document.createElement(‘input’); var isSupportPlaceholder = ‘placeholder’ in input; if(!isSupportPlaceholder) { var fakePlaceholder = angular.element( ‘‘ + attr[‘placeholder’] + ‘‘); fakePlaceholder.on(‘click’, function(e) { e.stopPropagation(); ele.focus(); }); fakePlaceholder.css({ ‘text-align’: ‘left’, ‘line-height’: ‘34px’ }); scope.getElementPosition = function() { return ele.position(); }; scope.$watch(scope.getElementPosition, function() { fakePlaceholder.css({ ‘top’: ele.position().top + ‘px’, ‘left’: ele.position().left + ‘px’ }); }, true); scope.getElementHeight = function() { return ele.outerHeight(); }; scope.$watch(scope.getElementHeight, function() { fakePlaceholder.css(‘height’, ele.outerHeight() + ‘px’); }); if(ele.css(‘font-size’)) { fakePlaceholder.css(‘font-size’, ele.css(‘font-size’)); } if(ele.css(‘width’)) { fakePlaceholder.css(‘width’, ele.css(‘width’)); } if(ele.css(‘text-indent’)) { fakePlaceholder.css(‘text-indent’, parseInt(ele.css(‘text-indent’)) + parseInt(ele.css(‘border-left-width’)) ); } if(ele.css(‘padding-left’)) { fakePlaceholder.css(‘padding-left’, ele.css(‘padding-left’)); } if(ele.css(‘margin-top’)) { fakePlaceholder.css(‘margin-top’, ele.css(‘margin-top’)); } ele.before(fakePlaceholder); $compile(fakePlaceholder)(scope); ele.on(‘focus’, function() { fakePlaceholder.hide(); }).on(‘blur’, function() { if(ele.val() === ‘’) { fakePlaceholder.show(); } }); scope.isElementVisible = function() { return ele.is(‘:visible’); }; scope.$watch(scope.isElementVisible, function() { var displayVal = ele.is(‘:visible’) ? ‘block’ : ‘none’; fakePlaceholder.css(‘display’, displayVal); if(displayVal === ‘blcok’ &amp;&amp; ele.val()) { fakePlaceholder.hide(); } }); scope.hasValue = function() { return ele.val(); }; scope.$watch(scope.hasValue, function() { if(ele.val()) { fakePlaceholder.hide(); } }); } } };}]); &lt;!–[if lte IE 9]&gt; &lt;script&gt; $(function(){ /placeholder兼容/ $(‘[placeholder]’).each(function(){ var defaultvalue=$(this).attr(“placeholder”); var altercss=$(this).attr(“altercss”); if($.trim($(this).val())===’’){ $(this).val(defaultvalue); if(altercss){$(this).addClass(altercss);} } $(this).focus(function(){ if($(this).val()==defaultvalue){ $(this).val(‘’); if(altercss){$(this).removeClass(altercss);} } }).blur(function(){ if($.trim($(this).val())===’’){ $(this).val(defaultvalue); if(altercss){$(this).addClass(altercss);} } }); }); }); &lt;/script&gt; &lt;![endif]–&gt; 以上有自己工作总结，欢迎广大群众提意见。真诚向您学习！！！！！！","categories":[{"name":"兼容，placeholder","slug":"兼容，placeholder","permalink":"https://luyuzeee.github.io/categories/兼容，placeholder/"}],"tags":[{"name":"兼容，placeholder，angularJs，IE","slug":"兼容，placeholder，angularJs，IE","permalink":"https://luyuzeee.github.io/tags/兼容，placeholder，angularJs，IE/"}]}]}